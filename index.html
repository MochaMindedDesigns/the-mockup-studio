<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mocha Minded Designs Mockup Studio</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>â˜•</text></svg>">
    
    <!-- Polyfill for Import Maps -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.10.0/dist/es-module-shims.js"></script>

    <!-- Import Map for ES Modules in the browser -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "jszip": "https://esm.sh/jszip@3.10.1",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.17.0"
  }
}
</script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        content: ["./index.html"],
        theme: {
          extend: {
            colors: {
              'mocha-dark': '#2E2522',
              'mocha-med': '#6F5E53',
              'mocha-light': '#A58E7F',
              'cream': '#F5EFE6',
              'latte': '#E8D5C4',
            },
            fontFamily: {
                sans: ['ui-sans-serif', 'system-ui']
            }
          },
        },
        plugins: [],
      }
    </script>
    
    <!-- Babel for in-browser JSX/TSX transpilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

</head>
<body class="bg-cream text-mocha-dark font-sans">
    <div id="root"></div>
    
    <!-- All application code consolidated here -->
    <script type="text/babel" data-type="module">
        import React from 'react';
        import ReactDOM from 'react-dom/client';
        import JSZip from 'jszip';

        // ===== CONSTANTS =====
        const PRODUCT_CATEGORIES = {
          'Apparel': ['T-Shirt', 'Hoodie', 'Sweatshirt', 'Tank Top', 'Long Sleeve Shirt', 'Crop Top', 'Polo Shirt', 'Jacket', 'Leggings', 'Shorts', 'Kids T-Shirt', 'Baby Onesie'],
          'Bags & Accessories': ['Tote Bag', 'Backpack', 'Phone Case', 'Cap', 'Beanie', 'Scarf', 'Socks', 'Fanny Pack'],
          'Drinkware': ['Mug', 'Tumbler', 'Water Bottle', 'Can Cooler', 'Wine Glass', 'Beer Stein'],
          'Home & Wall': ['Canvas Print', 'Poster', 'Pillow', 'Towel', 'Blanket', 'Coaster', 'Doormat', 'Apron'],
          'Seasonal': ['Ornament', 'Stocking', 'Ugly Christmas Sweater', 'Beach Towel'],
          'Stationery': ['Notebook', 'Greeting Card', 'Sticker', 'Journal', 'Bookmark', 'Enamel Pin'],
          'Tech': ['Laptop Sleeve', 'Mouse Pad', 'Tablet Case', 'AirPods Case'],
        };
        const STYLES = ['Angle', 'Flat Lay', 'Studio', 'Lifestyle-Lite', 'Seasonal'];
        const MODEL_GENDERS = ['Male', 'Female', 'Unisex', 'Boy', 'Girl'];
        const MODEL_ETHNICITIES = ['Asian', 'Black', 'Caucasian', 'Hispanic', 'Middle Eastern', 'South Asian', 'Pacific Islander', 'Indigenous', 'Mixed'];
        const PREDEFINED_COLORS = [
          '#ffffff', '#000000', '#f44336', '#e91e63', '#9c27b0', '#673ab7',
          '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50',
          '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722',
        ];
        const EXPORT_PRESETS = {
            'Etsy': { width: 2700, height: 2700 },
            'Shopify': { width: 2048, height: 2048 },
            'Instagram Post': { width: 1080, height: 1080 },
            'Instagram Story': { width: 1080, height: 1920 },
            'Pinterest': { width: 1000, height: 1500 },
            'Amazon': { width: 2000, height: 2000},
            'Custom': { width: 1024, height: 1024},
        };

        // ===== UTILITIES =====
        const resizeImage = (dataUrl, maxWidth = 800, maxHeight = 800) => new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                let { width, height } = img;
                if (width > height) {
                    if (width > maxWidth) {
                        height = Math.round((height * maxWidth) / width);
                        width = maxWidth;
                    }
                } else {
                    if (height > maxHeight) {
                        width = Math.round((width * maxHeight) / height);
                        height = maxHeight;
                    }
                }
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                if (!ctx) return reject(new Error('Could not get canvas context'));
                ctx.drawImage(img, 0, 0, width, height);
                const mimeType = dataUrl.substring(5, dataUrl.indexOf(';')) || 'image/png';
                resolve(canvas.toDataURL(mimeType));
            };
            img.onerror = (err) => reject(err);
            img.src = dataUrl;
        });

        // ===== SERVICES =====

        // --- geminiService ---
        // This function now acts as a client to our own backend proxy.
        async function callBackendApi(task, params) {
            const response = await fetch('/api/gemini', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ task, params }),
            });
            if (!response.ok) {
                // Try to parse the error, but fallback to a generic message
                let errorData;
                try {
                    errorData = await response.json();
                } catch(e) {
                    errorData = { error: `Request failed with status ${response.status}. Please try again.` };
                }
                throw new Error(errorData.error || 'API request failed');
            }
            return response.json();
        }

        async function generateMockupImage(prompt, numberOfImages) {
            const { images } = await callBackendApi('generateImage', { prompt, numberOfImages });
            return images; // The backend now returns an array of base64 strings
        }
        
        const dataUrlToParts = (dataUrl) => {
            if (!dataUrl) return { mimeType: 'image/png', data: ''};
            const parts = dataUrl.split(',');
            const mimeType = parts[0].match(/:(.*?);/)?.[1] || 'image/png';
            const data = parts[1];
            return { mimeType, data };
        };

        async function removeImageBackground(designDataUrl) {
            const { mimeType, data } = dataUrlToParts(designDataUrl);
            const { image } = await callBackendApi('removeBackground', { mimeType, data });
            return image; // Backend returns the full data URL string
        }

        async function applyDesignToMockup(blankMockupBase64, designDataUrl, productName) {
            const { mimeType: designMimeType, data: designBase64 } = dataUrlToParts(designDataUrl);
            const { image } = await callBackendApi('applyDesign', {
                blankMockupBase64,
                designMimeType,
                designBase64,
                productName,
            });
            return image; // Backend returns just the base64 data
        }

        async function addDesignedProductToBackground(params) {
            const { image } = await callBackendApi('addDesignedProductToBackground', params);
            return image; // Backend returns just the base64 data
        }

        async function generateSeoListing(productName, designDescription) {
            const { content } = await callBackendApi('generateSeo', { productName, designDescription });
            return content;
        }

        async function generateAltText(imageDataUrl) {
            const { mimeType, data } = dataUrlToParts(imageDataUrl);
            const { text } = await callBackendApi('generateAltText', { mimeType, data });
            return text;
        }


        // --- exportService ---
        const getExportDimensions = (settings) => {
            if (settings.preset === 'Custom') {
                return { width: settings.customWidth, height: settings.customHeight };
            }
            return EXPORT_PRESETS[settings.preset] || EXPORT_PRESETS['Etsy'];
        };

        const resizeCanvasToBlob = (canvas, width, height) => new Promise((resolve) => {
            const resizedCanvas = document.createElement('canvas');
            resizedCanvas.width = width;
            resizedCanvas.height = height;
            const ctx = resizedCanvas.getContext('2d');
            if (!ctx) { resolve(null); return; }
            ctx.drawImage(canvas, 0, 0, width, height);
            resizedCanvas.toBlob(resolve, 'image/png');
        });

        const downloadCanvasAsImage = async (canvas, filename, settings) => {
            const { width, height } = getExportDimensions(settings);
            const blob = await resizeCanvasToBlob(canvas, width, height);
            if (!blob) { console.error("Could not create blob from canvas"); return; }
            const link = document.createElement('a');
            link.href = URL.ObjectURL(blob);
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
        };

        const createImageFromDataURL = (dataURL) => new Promise((resolve, reject) => {
            const image = new Image();
            image.crossOrigin = 'anonymous';
            image.onload = () => resolve(image);
            image.onerror = reject;
            image.src = dataURL;
        });

        const applyWatermarkAndGetBlob = async (baseImage, settings, watermarkState) => {
            const canvas = document.createElement('canvas');
            canvas.width = baseImage.width; canvas.height = baseImage.height;
            const ctx = canvas.getContext('2d');
            if (!ctx) return null;
            ctx.drawImage(baseImage, 0, 0);
            if (watermarkState.image) {
                try {
                    const wmImage = await createImageFromDataURL(watermarkState.image);
                    ctx.globalAlpha = watermarkState.opacity;
                    const scale = 0.15;
                    const w = canvas.width * scale; const h = (w / wmImage.width) * wmImage.height;
                    let x = (canvas.width - w) / 2; let y = (canvas.height - h) / 2;
                    const margin = 20;
                    if (watermarkState.position === 'topLeft') { x = margin; y = margin; }
                    if (watermarkState.position === 'topRight') { x = canvas.width - w - margin; y = margin; }
                    if (watermarkState.position === 'bottomLeft') { x = margin; y = canvas.height - h - margin; }
                    if (watermarkState.position === 'bottomRight') { x = canvas.width - w - margin; y = canvas.height - h - margin; }
                    ctx.drawImage(wmImage, x, y, w, h);
                    ctx.globalAlpha = 1.0;
                } catch (error) { console.error("Failed to load watermark image for zip export", error); }
            }
            const { width, height } = getExportDimensions(settings);
            return resizeCanvasToBlob(canvas, width, height);
        };

        const downloadImagesAsZip = async (images, zipFilename, settings, watermark) => {
            const zip = new JSZip();
            const imageElements = await Promise.all(images.map(createImageFromDataURL));
            for (let i = 0; i < imageElements.length; i++) {
                const blob = await applyWatermarkAndGetBlob(imageElements[i], settings, watermark);
                if (blob) { zip.file(`mockup-${i + 1}.png`, blob); }
            }
            if (imageElements.length > 0) { zip.file("readme.txt", "This is your Mockup Set, generated by Mocha Minded Designs Mockup Studio."); }
            const zipBlob = await zip.generateAsync({ type: 'blob' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(zipBlob);
            link.download = zipFilename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
        };

        // ===== ICONS =====
        const CoffeeIcon = ({ className }) => (<svg className={className} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 14c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" /></svg>);
        const UploadIcon = ({ className }) => (<svg className={className} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>);
        const LoadingIcon = ({ className }) => (<svg className={className} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>);
        const DownloadIcon = ({ className }) => (<svg className={className} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>);
        const ZipIcon = ({ className }) => (<svg className={className} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13" /></svg>);
        const SparklesIcon = ({ className }) => (<svg className={className} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M5 3v4M3 5h4M6.225 6.225L8.65 8.65m5.475-5.475L15.775 5M12 20v-4M10 18h4m-1.5-1.5L15 14m-5-5l2.5-2.5" /></svg>);
        const AltTextIcon = ({ className }) => (<svg className={className} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M4 6h16M4 12h16M4 18h7" /></svg>);
        const PositionTopLeft = ({ className }) => <svg className={className} viewBox="0 0 24 24" fill="currentColor"><path d="M4 4h6v6H4z"/></svg>;
        const PositionTopRight = ({ className }) => <svg className={className} viewBox="0 0 24 24" fill="currentColor"><path d="M14 4h6v6h-6z"/></svg>;
        const PositionCenter = ({ className }) => <svg className={className} viewBox="0 0 24 24" fill="currentColor"><path d="M9 9h6v6H9z"/></svg>;
        const PositionBottomLeft = ({ className }) => <svg className={className} viewBox="0 0 24 24" fill="currentColor"><path d="M4 14h6v6H4z"/></svg>;
        const PositionBottomRight = ({ className }) => <svg className={className} viewBox="0 0 24 24" fill="currentColor"><path d="M14 14h6v6h-6z"/></svg>;

        // ===== COMPONENTS =====
        const Header = () => (
            <header className="bg-mocha-dark text-cream p-4 shadow-md">
                <div className="container mx-auto flex items-center justify-between">
                    <div className="flex items-center space-x-3">
                        <CoffeeIcon className="w-8 h-8 text-latte" />
                        <h1 className="text-xl md:text-2xl font-bold tracking-wider">Mocha Minded Designs Mockup Studio</h1>
                    </div>
                </div>
            </header>
        );

        const Section = ({ title, children }) => (
            <div className="space-y-3">
                <h3 className="text-sm font-bold text-mocha-med uppercase tracking-wider">{title}</h3>
                {children}
            </div>
        );

        const FileInput = ({ id, label, onChange, file }) => {
            const handleFileChange = async (e) => {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = async (event) => {
                         if (event.target?.result) {
                            try {
                                const resizedDataUrl = await resizeImage(event.target.result);
                                onChange(resizedDataUrl);
                            } catch (error) {
                                console.error("Image resizing failed:", error);
                                onChange(event.target.result); // Fallback to original
                            }
                        }
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
            };
            return (
                <div>
                    <label htmlFor={id} className="cursor-pointer bg-white border border-mocha-light rounded-md p-3 flex items-center justify-center text-mocha-med hover:bg-latte/50 transition-colors">
                        <UploadIcon className="w-5 h-5 mr-2" />
                        <span>{file ? "Change" : "Upload"} {label}</span>
                    </label>
                    <input id={id} type="file" accept="image/png, image/jpeg" className="hidden" onChange={handleFileChange} />
                    {file && <img src={file} alt={`${label} preview`} className="mt-2 rounded-md max-h-20 object-contain mx-auto" />}
                </div>
            );
        };

        const ControlPanel = ({ controlState, setControlState, onGenerate, isLoading }) => {
            const handleStateChange = React.useCallback((key, value) => {
                setControlState(prevState => {
                    const newState = { ...prevState, [key]: value };
                    if (key === 'productCategory') {
                        newState.product = PRODUCT_CATEGORIES[value][0];
                    }
                    return newState;
                });
            }, [setControlState]);
            const productOptions = React.useMemo(() => PRODUCT_CATEGORIES[controlState.productCategory] || [], [controlState.productCategory]);
            return (
                <div className="bg-white p-4 rounded-lg shadow-lg space-y-6 h-full">
                    <Section title="1. Your Design"><FileInput id="design-upload" label="Your Artwork" file={controlState.design} onChange={file => handleStateChange('design', file)} /></Section>
                    <Section title="2. Product & Style">
                        <select value={controlState.productCategory} onChange={e => handleStateChange('productCategory', e.target.value)} className="w-full p-2 border border-mocha-light rounded-md bg-white focus:ring-2 focus:ring-mocha-med"><option value="" disabled>Category</option>{Object.keys(PRODUCT_CATEGORIES).map(cat => <option key={cat} value={cat}>{cat}</option>)}</select>
                        <select value={controlState.product} onChange={e => handleStateChange('product', e.target.value)} className="w-full p-2 border border-mocha-light rounded-md bg-white focus:ring-2 focus:ring-mocha-med"><option value="" disabled>Product</option>{productOptions.map(prod => <option key={prod} value={prod}>{prod}</option>)}</select>
                        <select value={controlState.style} onChange={e => handleStateChange('style', e.target.value)} className="w-full p-2 border border-mocha-light rounded-md bg-white focus:ring-2 focus:ring-mocha-med">{STYLES.map(style => <option key={style} value={style}>{style}</option>)}</select>
                    </Section>
                    <Section title="3. Customization">
                        <div>
                            <label className="block text-xs font-medium text-mocha-med mb-1">Product Color</label>
                            <div className="flex items-center space-x-2">
                                <input type="color" value={controlState.productColor} onChange={e => handleStateChange('productColor', e.target.value)} className="w-10 h-10 p-1 border border-mocha-light rounded-md" />
                                <input type="text" value={controlState.productColor} onChange={e => handleStateChange('productColor', e.target.value)} className="w-full p-2 border border-mocha-light rounded-md bg-white focus:ring-2 focus:ring-mocha-med" placeholder="#ffffff"/>
                            </div>
                            <div className="grid grid-cols-6 gap-2 mt-2">{PREDEFINED_COLORS.map(color => (<button key={color} onClick={() => handleStateChange('productColor', color)} className={`w-full h-8 rounded border ${controlState.productColor === color ? 'ring-2 ring-offset-2 ring-mocha-med' : 'border-mocha-light'}`} style={{ backgroundColor: color }} />))}</div>
                        </div>
                        {controlState.productCategory === 'Apparel' && (<>
                            <select value={controlState.modelGender} onChange={e => handleStateChange('modelGender', e.target.value)} className="w-full p-2 border border-mocha-light rounded-md bg-white focus:ring-2 focus:ring-mocha-med">{MODEL_GENDERS.map(g => <option key={g} value={g}>{g}</option>)}</select>
                            <select value={controlState.modelEthnicity} onChange={e => handleStateChange('modelEthnicity', e.target.value)} className="w-full p-2 border border-mocha-light rounded-md bg-white focus:ring-2 focus:ring-mocha-med">{MODEL_ETHNICITIES.map(e => <option key={e} value={e}>{e}</option>)}</select>
                        </>)}
                        <div className="flex space-x-2">
                            <button onClick={() => handleStateChange('background', 'white')} className={`flex-1 p-2 rounded-md text-sm ${controlState.background === 'white' ? 'bg-mocha-dark text-white' : 'bg-gray-200'}`}>White BG</button>
                            <button onClick={() => handleStateChange('background', 'styled')} className={`flex-1 p-2 rounded-md text-sm ${controlState.background === 'styled' ? 'bg-mocha-dark text-white' : 'bg-gray-200'}`}>Styled BG</button>
                        </div>
                        <FileInput id="bg-upload" label="Custom BG" file={controlState.customBackground} onChange={file => { handleStateChange('customBackground', file); if(file) handleStateChange('background', 'custom') }} />
                    </Section>
                    <button onClick={onGenerate} disabled={isLoading || !controlState.design} className="w-full bg-mocha-med text-white font-bold py-3 px-4 rounded-md hover:bg-mocha-dark transition-colors disabled:bg-mocha-light disabled:cursor-not-allowed">{isLoading ? 'Generating...' : 'Generate Mockups'}</button>
                </div>
            );
        };
        
        const PreviewPanel = React.forwardRef(({ baseImages, watermark, isLoading, loadingMessage, activeIndex, setActiveIndex }, ref) => {
            const canvasRef = React.useRef(null);
            const activeImageSrc = baseImages && baseImages.length > 0 ? baseImages[activeIndex] : null;
            React.useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                if (!ctx) return;
                if (!activeImageSrc) { ctx.clearRect(0, 0, canvas.width, canvas.height); return; }
                const base = new Image();
                base.crossOrigin = "anonymous";
                base.onload = () => {
                    canvas.width = base.width; canvas.height = base.height;
                    ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.drawImage(base, 0, 0);
                    drawWatermark();
                };
                base.src = activeImageSrc;
                const drawWatermark = () => {
                    const afterWatermarkDrawn = () => {
                        if (ref && 'current' in ref && ref.current) {
                            const destCtx = ref.current.getContext('2d');
                            if(destCtx) {
                                ref.current.width = canvas.width; ref.current.height = canvas.height;
                                destCtx.drawImage(canvas, 0, 0);
                            }
                        }
                    };
                    if (watermark.image) {
                        const wm = new Image();
                        wm.crossOrigin = "anonymous";
                        wm.onload = () => {
                            ctx.globalAlpha = watermark.opacity;
                            const scale = 0.15; const w = canvas.width * scale; const h = (w / wm.width) * wm.height;
                            let x = (canvas.width - w) / 2; let y = (canvas.height - h) / 2; const margin = 20;
                            if (watermark.position === 'topLeft') { x = margin; y = margin; }
                            if (watermark.position === 'topRight') { x = canvas.width - w - margin; y = margin; }
                            if (watermark.position === 'bottomLeft') { x = margin; y = canvas.height - h - margin; }
                            if (watermark.position === 'bottomRight') { x = canvas.width - w - margin; y = canvas.height - h - margin; }
                            ctx.drawImage(wm, x, y, w, h);
                            ctx.globalAlpha = 1.0;
                            afterWatermarkDrawn();
                        };
                        wm.src = watermark.image;
                    } else { afterWatermarkDrawn(); }
                };
            }, [activeImageSrc, watermark, ref]);
            return (
                <div className="bg-white p-4 rounded-lg shadow-lg flex flex-col justify-between aspect-square h-full">
                    <div className="flex-grow flex items-center justify-center relative min-h-0">
                        {isLoading && (<div className="text-center text-mocha-med"><LoadingIcon className="w-12 h-12 mx-auto animate-spin" /><p className="mt-4 font-semibold">{loadingMessage}</p></div>)}
                        {!isLoading && (!baseImages || baseImages.length === 0) && (
                            <div className="text-center text-mocha-light p-8">
                                <p className="font-semibold text-lg">Your Mockup Preview</p>
                                <p>Upload your design and click "Generate Mockups" to see them here.</p>
                            </div>
                        )}
                        <canvas ref={canvasRef} className={`max-w-full max-h-full object-contain ${isLoading || !activeImageSrc ? 'hidden' : ''}`} />
                    </div>
                    {baseImages && baseImages.length > 0 && !isLoading && (<div className="flex-shrink-0 pt-4"><div className="flex items-center justify-center gap-2">{baseImages.map((image, index) => (<button key={index} onClick={() => setActiveIndex(index)} className={`w-16 h-16 rounded-md overflow-hidden border-2 ${index === activeIndex ? 'border-mocha-med' : 'border-transparent'}`}><img src={image} alt={`Mockup thumbnail ${index + 1}`} className="w-full h-full object-cover"/></button>))}</div></div>)}
                    <canvas ref={ref} className="hidden" />
                </div>
            );
        });

        const MarketingPanel = ({ watermark, setWatermark, seoContent, altText, onGenerateSeo, onGenerateAltText, isLoading, mockupGenerated, onDownload, onBatchExport, exportSettings, setExportSettings }) => {
            const handleWatermarkFileChange = (e) => {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = (event) => setWatermark(prev => ({ ...prev, image: event.target?.result }));
                    reader.readAsDataURL(e.target.files[0]);
                }
            };
            const handleWatermarkOpacityChange = (e) => setWatermark(prev => ({...prev, opacity: parseFloat(e.target.value)}));
            const handleWatermarkPositionChange = (position) => setWatermark(prev => ({...prev, position}));
            const handleExportPresetChange = (e) => {
                const preset = e.target.value;
                const dimensions = EXPORT_PRESETS[preset] || {width: 1024, height: 1024};
                setExportSettings({ preset, customWidth: dimensions.width, customHeight: dimensions.height });
            }
            return (
                <div className="bg-white p-4 rounded-lg shadow-lg space-y-6 h-full">
                    <div className="space-y-3"><h3 className="text-sm font-bold text-mocha-med uppercase tracking-wider">Watermark</h3><div className="p-4 bg-latte/30 rounded-md space-y-3">
                        <FileInput id="watermark-upload" label="Watermark" file={watermark.image} onChange={img => setWatermark(prev => ({ ...prev, image: img }))} />
                        {watermark.image && (<><label className="text-xs font-medium text-mocha-med">Opacity: {Math.round(watermark.opacity * 100)}%</label><input type="range" min="0" max="1" step="0.05" value={watermark.opacity} onChange={handleWatermarkOpacityChange} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-mocha-med"/><div className="flex justify-between">{[{ pos: 'topLeft', icon: <PositionTopLeft className="w-5 h-5"/> }, { pos: 'topRight', icon: <PositionTopRight className="w-5 h-5"/> }, { pos: 'center', icon: <PositionCenter className="w-5 h-5"/> }, { pos: 'bottomLeft', icon: <PositionBottomLeft className="w-5 h-5"/> }, { pos: 'bottomRight', icon: <PositionBottomRight className="w-5 h-5"/> }].map(({pos, icon}) => (<button key={pos} onClick={() => handleWatermarkPositionChange(pos)} className={`p-2 rounded ${watermark.position === pos ? 'bg-mocha-med text-white' : 'bg-white'}`}>{icon}</button>))}</div></>)}
                    </div></div>
                    <div className="space-y-3"><h3 className="text-sm font-bold text-mocha-med uppercase tracking-wider">Auto-Generate Listings</h3><div className="p-4 bg-latte/30 rounded-md space-y-3">
                        <button onClick={onGenerateSeo} disabled={!mockupGenerated || isLoading} className="w-full flex items-center justify-center gap-2 bg-mocha-med text-white font-bold py-2 px-4 rounded-md hover:bg-mocha-dark transition-colors disabled:bg-mocha-light disabled:cursor-not-allowed"><SparklesIcon className="w-5 h-5" /> Generate SEO Listing</button>
                        {seoContent && (<div className="text-xs space-y-2 max-h-48 overflow-y-auto p-2 bg-white rounded-md"><p><strong>Title:</strong> {seoContent.title}</p><p><strong>Description:</strong> {seoContent.description}</p><p><strong>Features:</strong> {seoContent.features.join(', ')}</p><p><strong>Tags:</strong> {seoContent.tags.join(', ')}</p></div>)}
                        <button onClick={onGenerateAltText} disabled={!mockupGenerated || isLoading} className="w-full flex items-center justify-center gap-2 bg-mocha-med text-white font-bold py-2 px-4 rounded-md hover:bg-mocha-dark transition-colors disabled:bg-mocha-light disabled:cursor-not-allowed"><AltTextIcon className="w-5 h-5" /> Generate Alt Text</button>
                        {altText.length > 0 && (<div className="text-xs space-y-2 max-h-48 overflow-y-auto p-2 bg-white rounded-md">{altText.map((text, index) => (<p key={index}><strong>Image {index + 1}:</strong> {text}</p>))}</div>)}
                    </div></div>
                    <div className="space-y-3"><h3 className="text-sm font-bold text-mocha-med uppercase tracking-wider">Export</h3><div className="p-4 bg-latte/30 rounded-md space-y-3">
                        <select value={exportSettings.preset} onChange={handleExportPresetChange} className="w-full p-2 border border-mocha-light rounded-md bg-white focus:ring-2 focus:ring-mocha-med">{Object.keys(EXPORT_PRESETS).map(p => <option key={p} value={p}>{p}</option>)}</select>
                        {exportSettings.preset === 'Custom' && (<div className="flex gap-2"><input type="number" value={exportSettings.customWidth} onChange={(e) => setExportSettings(s=>({...s, customWidth: parseInt(e.target.value, 10)}))} placeholder="Width" className="w-1/2 p-2 border border-mocha-light rounded-md"/><input type="number" value={exportSettings.customHeight} onChange={(e) => setExportSettings(s=>({...s, customHeight: parseInt(e.target.value, 10)}))} placeholder="Height" className="w-1/2 p-2 border border-mocha-light rounded-md"/></div>)}
                        <button onClick={onDownload} disabled={!mockupGenerated || isLoading} className="w-full flex items-center justify-center gap-2 bg-mocha-med text-white font-bold py-2 px-4 rounded-md hover:bg-mocha-dark transition-colors disabled:bg-mocha-light disabled:cursor-not-allowed"><DownloadIcon className="w-5 h-5" /> Download Mockup</button>
                        <button onClick={onBatchExport} disabled={!mockupGenerated || isLoading} className="w-full flex items-center justify-center gap-2 bg-mocha-med text-white font-bold py-2 px-4 rounded-md hover:bg-mocha-dark transition-colors disabled:bg-mocha-light disabled:cursor-not-allowed"><ZipIcon className="w-5 h-5" /> Export Images (ZIP)</button>
                    </div></div>
                </div>
            );
        };

        // ===== APP COMPONENT =====
        function App() {
          const [controlState, setControlState] = React.useState({ design: null, productCategory: 'Apparel', product: 'T-Shirt', style: 'Studio', productColor: '#ffffff', modelGender: 'Female', modelEthnicity: 'Caucasian', background: 'white', customBackground: null });
          const [watermark, setWatermark] = React.useState({ image: null, opacity: 0.5, position: 'center' });
          const [exportSettings, setExportSettings] = React.useState({ preset: 'Etsy', customWidth: 2700, customHeight: 2700 });
          const [mockupImages, setMockupImages] = React.useState([]);
          const [seoContent, setSeoContent] = React.useState(null);
          const [altText, setAltText] = React.useState([]);
          const [isLoading, setIsLoading] = React.useState(false);
          const [loadingMessage, setLoadingMessage] = React.useState('');
          const [error, setError] = React.useState('');
          const [activeIndex, setActiveIndex] = React.useState(0);
          const finalCanvasRef = React.useRef(null);

          const handleGenerateMockup = React.useCallback(async () => {
            setIsLoading(true); setError(''); setMockupImages([]); setActiveIndex(0);
            
            try {
              if (controlState.background === 'custom' && controlState.customBackground) {
                  // Custom background flow: places the product onto the user's background.
                  setLoadingMessage('Adding product to your background...');
                  if (!controlState.design) {
                      throw new Error('Please upload a design to apply to the custom background.');
                  }
                  const { mimeType: designMimeType, data: designBase64 } = dataUrlToParts(controlState.design);
                  const { mimeType: backgroundMimeType, data: backgroundBase64 } = dataUrlToParts(controlState.customBackground);
                  
                  const resultBase64 = await addDesignedProductToBackground({
                      backgroundBase64, backgroundMimeType,
                      designBase64, designMimeType,
                      productName: controlState.product,
                      productColor: controlState.productColor,
                  });
                  setMockupImages([`data:image/png;base64,${resultBase64}`]);
              } else {
                  // Standard flow: generates mockups from scratch.
                  let backgroundPrompt = `on a neutral, solid light gray background to isolate the product.`;
                  if (controlState.background === 'styled') {
                      backgroundPrompt = `in a styled scene that complements a ${controlState.style} product photo.`;
                  }

                  let modelPrompt = '';
                  if (controlState.productCategory === 'Apparel') {
                      const isChildModel = controlState.modelGender === 'Boy' || controlState.modelGender === 'Girl';
                      const modelAge = isChildModel ? `a child ${controlState.modelGender.toLowerCase()}` : `an adult`;
                      modelPrompt = `The ${controlState.product} is worn by a ${controlState.modelEthnicity} ${modelAge} model. The model's face is not shown to keep the focus on the product.`;
                  }
                  
                  const prompt = `Photorealistic ${controlState.style} mockup of a blank ${controlState.productColor} ${controlState.product}, shown ${backgroundPrompt} ${modelPrompt} The product must be completely blank, with no logos or text. High-quality commercial photography.`;

                  const initialBlankMockupsBase64 = [];
                  for (let i = 0; i < 4; i++) {
                      setLoadingMessage(`Generating photorealistic mockups (${i + 1} of 4)...`);
                      const result = await generateMockupImage(prompt, 1);
                      if (result && result.length > 0) {
                          initialBlankMockupsBase64.push(result[0]);
                      } else {
                          throw new Error(`Mockup generation failed on image ${i + 1}. The AI may have returned an empty response.`);
                      }
                  }
                  
                  setLoadingMessage('Optimizing mockups...');
                  const resizedBlankMockupsBase64 = await Promise.all(
                    initialBlankMockupsBase64.map(async (base64) => {
                      const dataUrl = `data:image/png;base64,${base64}`;
                      const resizedDataUrl = await resizeImage(dataUrl);
                      const parts = resizedDataUrl.split(',');
                      return parts[1]; // Return just the base64 part
                    })
                  );

                  setLoadingMessage('Removing background from your design...');
                  const designWithTransparentBg = await removeImageBackground(controlState.design);
                  
                  setLoadingMessage('Applying your design to 4 mockups...');
                  const appliedDesignsBase64 = await Promise.all(
                      resizedBlankMockupsBase64.map(blankMockup => 
                          applyDesignToMockup(blankMockup, designWithTransparentBg, controlState.product)
                      )
                  );
                  const finalMockupDataUrls = appliedDesignsBase64.map(img => `data:image/png;base64,${img}`);
                  setMockupImages(finalMockupDataUrls);
              }
            } catch (e) { 
              console.error(e); 
              setError(e.message || 'Failed to generate mockups. Please try again.'); 
            } finally { 
              setIsLoading(false); 
              setLoadingMessage(''); 
            }
          }, [controlState]);

          const handleGenerateSeo = React.useCallback(async () => {
            if (mockupImages.length === 0 || !controlState.design) { setError('Please generate mockups and upload a design first.'); return; }
            setIsLoading(true); setLoadingMessage('Generating SEO content...'); setError(''); setSeoContent(null);
            try {
              const content = await generateSeoListing(controlState.product, 'a custom user-provided design');
              setSeoContent(content);
            } catch (e) { console.error(e); setError('Failed to generate SEO content.'); } 
            finally { setIsLoading(false); setLoadingMessage(''); }
          }, [mockupImages, controlState.product, controlState.design]);

          const handleGenerateAltText = React.useCallback(async () => {
            if (mockupImages.length === 0) { setError('Please generate mockups first.'); return; }
            setIsLoading(true); setLoadingMessage(`Generating alt text for ${mockupImages.length} images...`); setError(''); setAltText([]);
            try {
              const texts = await Promise.all(mockupImages.map(image => generateAltText(image)));
              setAltText(texts);
            } catch (e) { console.error(e); setError('Failed to generate alt text.'); } 
            finally { setIsLoading(false); setLoadingMessage(''); }
          }, [mockupImages]);

          const handleDownload = () => {
              if (finalCanvasRef.current) downloadCanvasAsImage(finalCanvasRef.current, `mockup-${activeIndex + 1}.png`, exportSettings);
              else setError("Preview canvas not available for download.");
          };

          const handleBatchExport = async () => {
            if (mockupImages.length > 0) {
              setIsLoading(true); setLoadingMessage('Exporting images...');
              await downloadImagesAsZip(mockupImages, 'Mockup-Images.zip', exportSettings, watermark);
              setIsLoading(false); setLoadingMessage('');
            } else { setError("No mockups available for batch export."); }
          };

          return (
            <div className="min-h-screen bg-cream font-sans">
              <Header />
              <main className="p-4 lg:p-8">
                <div className="grid grid-cols-1 lg:grid-cols-12 gap-8">
                  <div className="lg:col-span-3"><ControlPanel controlState={controlState} setControlState={setControlState} onGenerate={handleGenerateMockup} isLoading={isLoading} /></div>
                  <div className="lg:col-span-6"><PreviewPanel ref={finalCanvasRef} baseImages={mockupImages} watermark={watermark} isLoading={isLoading} loadingMessage={loadingMessage} activeIndex={activeIndex} setActiveIndex={setActiveIndex} /></div>
                  <div className="lg:col-span-3"><MarketingPanel watermark={watermark} setWatermark={setWatermark} seoContent={seoContent} altText={altText} onGenerateSeo={handleGenerateSeo} onGenerateAltText={handleGenerateAltText} isLoading={isLoading} mockupGenerated={mockupImages.length > 0} onDownload={handleDownload} onBatchExport={handleBatchExport} exportSettings={exportSettings} setExportSettings={setExportSettings}/></div>
                </div>
                {error && (<div className="fixed bottom-4 right-4 bg-red-500 text-white p-4 rounded-lg shadow-lg max-w-sm"><p><strong>Error:</strong> {error}</p><button onClick={() => setError('')} className="absolute top-1 right-2 text-white font-bold">&times;</button></div>)}
              </main>
            </div>
          );
        }

        // ===== RENDER APP =====
        const rootElement = document.getElementById('root');
        if (!rootElement) {
          throw new Error("Could not find root element to mount to");
        }
        const root = ReactDOM.createRoot(rootElement);
        root.render(<App />);

    </script>
</body>
</html>
